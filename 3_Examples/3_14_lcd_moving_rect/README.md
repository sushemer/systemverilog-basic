# 3.14 LCD – Moving Rectangle

This example is the **direct continuation** of `3_13_lcd` (static shapes):

- Now the rectangle **moves horizontally** on the screen.
- A `strobe_gen` module is used to generate a slow pulse (~30 Hz).
- Each pulse increments a counter that shifts the rectangle.
- The rectangle’s position is displayed on:
  - The **LEDs** (8 least significant bits).
  - The **7-segment display**.

It is the first step toward animations and mini-games on the LCD.

---

## Objective

At the end of this example, the user will be able to:

- Understand how to use a **strobe** (slow pulse) to animate graphics.
- Control the position of a figure based on a **counter**.
- Relate:
  - Sequential logic (counter).
  - Combinational logic (comparisons using `x`, `y`).
  - Visual representation on the LCD.

---

## Relevant signals and parameters

### Main inputs

- `clock`  
  Main FPGA clock (≈ 27 MHz).

- `slow_clock`  
  Slow clock generated by the board wrapper (not used in this example, but kept as a port for compatibility with other labs).

- `reset`  
  Active-high asynchronous reset.

- `key[7:0]`  
  Reserved for later exercises (keys are not used in this example).

### Main outputs

- `led[7:0]`  
  Show the 8 least significant bits of the rectangle’s horizontal position (`rect_offset[7:0]`).

- `abcdefgh[7:0]`, `digit[7:0]`  
  Outputs of the TM1638 7-segment display:

  - The module `seven_segment_display` is used to show `rect_offset` as a number.
  - `dots` is kept at 0 (`8'b0000_0000`) in this example.

- `red[4:0]`, `green[5:0]`, `blue[4:0]`  
  Color of the current pixel on the LCD:

  - Default black background.
  - A red rectangle that moves horizontally.

- `gpio[3:0]`  
  Not used in this example (they can remain disconnected or high-impedance depending on the wrapper).

### LCD coordinates

The board’s video logic provides:

- `x[8:0]` → horizontal pixel coordinate (`0` to `479`).
- `y[8:0]` → vertical pixel coordinate (`0` to `271`).

In this example the following parameters are defined explicitly:

- `SCREEN_WIDTH  = 480`
- `SCREEN_HEIGHT = 272`

to make the screen size clear.

---

## Strobe and position counter

To avoid moving the rectangle **too fast**, the design does not increment the position on **every clock cycle**, but only when a **slow pulse** (`pulse`) generated by `strobe_gen` arrives.

The code uses something equivalent to:

    strobe_gen #(
        .clk_mhz   (27),
        .strobe_hz (30)   // ~30 pulses per second
    ) i_strobe_gen (
        .clk    (clock),
        .rst    (reset),
        .strobe (pulse)
    );

- `clk_mhz = 27` indicates that the input clock is approximately 27 MHz.
- `strobe_hz = 30` generates a high pulse (`pulse = 1`) about 30 times per second.
- Each pulse is used to advance the rectangle’s horizontal position.

The horizontal position counter:

- Is implemented with a signal `rect_offset[8:0]`.
- Increments only when `pulse` arrives.
- When it reaches a limit (for example `SCREEN_WIDTH / 2`), it resets to 0 so the rectangle returns to the start.

Conceptually:

1. If `reset` is active:
   - `rect_offset` is reset to 0.
2. If a `pulse` arrives:
   - If `rect_offset` has reached the limit, it returns to 0.
   - Otherwise, it increments by 1.

This creates a “sawtooth” horizontal movement: it advances to a point and then resets to the beginning.

---

## Visualization of the position on LEDs and 7-segment display

The calculated position (`rect_offset`) is reused to show debug information:

- **LEDs**:

      led = rect_offset[7:0];

  This displays the lower byte of the position counter in binary.

- **7-segment display**:

  - `seven_segment_display` is instantiated with `w_digit = 8` to use all 8 digits of the TM1638.
  - The input `number` receives `rect_offset` (internally extended).
  - `dots` remains `8'b0000_0000`.

This allows the user to:

- See the rectangle on the LCD.
- See the numerical position on the TM1638.
- See the binary position on the LEDs.

---

## Rectangle parameters on the LCD

The red rectangle is defined by:

- A **width** (`RECT_WIDTH`) in pixels.
- A **height** (`RECT_HEIGHT`) in pixels.
- A base position in `x` (`RECT_X_BASE`).
- A base position in `y` (`RECT_Y_TOP`).

Then the **effective** position is computed by adding the offset:

- `rect_x_left  = RECT_X_BASE + rect_offset;`
- `rect_x_right = rect_x_left + RECT_WIDTH;`

Thus:

- When `rect_offset = 0`, the rectangle starts around `RECT_X_BASE`.
- As `rect_offset` increases, the rectangle moves to the right.

Vertically (`y`), it stays fixed, for example:

- From `RECT_Y_TOP` to `RECT_Y_TOP + RECT_HEIGHT`.

---

## Color logic

The color logic is implemented as a purely combinational block, usually with `always_comb`:

1. First, set a **black background**:

   - `red   = 0;`
   - `green = 0;`
   - `blue  = 0;`

2. Then check whether the current pixel `(x, y)` is inside the rectangle:

   - If `x` is between `rect_x_left` and `rect_x_right`,
   - And `y` is between `RECT_Y_TOP` and `RECT_Y_TOP + RECT_HEIGHT`,

3. If true, overwrite the color:

   - `red   = 31;`  (maximum red)
   - `green = 0;`
   - `blue  = 0;`

If additional elements (bars, text, etc.) are added later, more conditions may be added, respecting the priority of the last `if` that assigns color.

---

## Relationship with example 3.13

Compared to `3_13_lcd` (static shapes):

- In `3_13` the shapes (bars, central rectangle) are **fixed**:
  - The regions are defined only by comparing `x` and `y`.
  - No counters or strobes are used.

- In `3_14`, the following are added:
  - A **slow clock** (`strobe_gen`) to move shapes at a controlled pace.
  - A **counter** that modifies the `x` comparisons.
  - Visualization of internal state (`rect_offset`) on LEDs and the 7-segment display.

This example serves as a bridge toward:

- More complex animations.
- Mini-games on the LCD.
- Interaction using inputs (keys, sensors, encoder) to move elements.

---

## Ideas to extend the example

Some possible variations as exercises:

- Allow keys (`key`) to change:
  - The **speed** (`strobe_hz` or divider).
  - The **direction** (left/right).

- Add a **horizontal bar** (as in `3_13`) and make the rectangle collide with it.

- Change the rectangle’s color based on position or external input z
---

With this example, the user now has a clear foundation to combine:

- A **counter** driven by a **strobe**.
- Combinational logic based on `x`, `y`, and other parameters.
- Simultaneous representation on the **LCD**, **LEDs**, and **7-segment display**.
